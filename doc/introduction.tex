\section{Introduction} \label{sec:introduction}
The Brainf*ck\footnote{The asterisk was inserted by the authors and is not part of the official name.} (BF) programming language is an esoteric programming language that is essebtually impossible - or at least highly unpractical - to actually write useful programs in. Even if you would become a very skilled programmer in this language, the resulting programs would be incredibly slow to execute. Despite this, many programmers have challenged themselves to write stunning pieces of code just for fun, or for the learning experience it offers. In doing so, it teaches us about computer architecture, compilers/interpreters, memory, pointers and much more. For more information on the language itself, see chapter \ref{sec:brainfck}.

\paragraph{Goals} The main goal of this project was to build a computer that can actually run BF code natively. Normally, after having written some new piece of BF, the programmer presents this code to some program that either compiles it to an executable native to the host architecture, or interprets it in a virtual Brainf*ck machine. However, rather than viewing BF as a language that needs to be compiled or interpreted, why not view it as the instruction set of a, yet to exist, Brainf*ck-CPU?

Our goal was to build this Brainf*ck CPU without making use of any programmable chips; only use Transistor-Transistor-Logic (TTL) chips such as registers, buffers and (de)multiplexers in addition to the necessary RAM and ROM. The computer was to be implemented entirely on breadboards, as it was inspired by Ben Eater's 8-bit breadboard computer \cite{beneater}. It should be able to run any compliant BF program directly, as long as it fits in the program ROM and does not exhaust the available amount of memory or stack-space. In other words: the computer should be capable of running canonical BF without doing any preprocessing steps like pre-calculating jump-addresses.

\paragraph{Outcome}
Over roughly 2.5 years (intermittently), the design evolved into a stable microcoded CPU with a Harvard-like memory map, a two-phase clock that can drive the system at over 200kHz, and a supporting software toolchain (assembler, EEPROM programmer, microcode compiler and emulation library) that makes prototyping, editing, assembling, and flashing programs and microcode practical. It has a sophisticated IO module that handles both input (both random numbers and keyboard input) and output (to a 4x20 character LCD display). This IO module is driven by an Atmega328P to be able to manage IO buffers, interpret the PS2 protocol and drive the screen, in addition to managing all the IO settings (echo, autoscroll, output-modes, etc). A deliberate choice was made to use a programmable chip in this case, since it is not really part of the CPU itself and makes the IO capabilities a lot more advanced and convenient. The machine has been tested by running many different BF programs on it that can be found online, validating its stability and BF-standard conformity (if such a thing even exists). The source code for all supporting software is available on Github at \url{https://github.com/jorenheit/bfcpu}.

\paragraph{Document structure.}
  Section~\ref{sec:bf} recaps BF as an ISA, Section~\ref{sec:arch} describes the architecture, Section~\ref{sec:ctrl} explains microcode and control sequences, Section~\ref{sec:impl} discusses hardware implementation and debugging and Section~\ref{sec:utils} covers supporting utilities. We conclude in Section~\ref{sec:conclusion}. Appendices contain tables, microcode listings, BOM, and schematics.
