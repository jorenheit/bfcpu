\section{Implementation} \label{sec:implementation}
\subsection{Registers} \label{sec:implementation:registers}
This section elucidates the intricate facets concerning the register-module implementation. It delves into the architectural nuances encompassing the driver module, data-pointer register, data structures, stack functionality, loop-skip mechanisms, instruction parsing, instruction-pointer management, and the flag register. By the conclusion of this chapter, a comprehensive overview integrating these components will be presented, encapsulating the holistic framework of the register-module.

\subsubsection{Overview}
Within the BFCPU framework, the ALU was intentionally omitted due to the constrained mathematical operations inherent in brainfck language, limited to singular addition and subtraction by one. To streamline complexity, our approach involved the utilization of 74LS193 and 74LS161 integrated chips, enabling the creation of discrete registers. These chips offer both memory storage capabilities and the ability to increment values. Moreover, the 74LS193 chip encompasses the added functionality of decrementing stored values, although such functionality remains unnecessary for the F-R component. Hence, the choice of 74LS** was deliberate, selected for its singular provision of 4-bit value storage, aligning precisely with the requirements of the system.

\subsubsection{Common INC-DEC functionality problem}
The Register module's intricate configuration involves numerous INC and DEC pins, necessitating manipulation by the control unit to modify register values. To streamline and unify this process, the Driver module acts as a centralized interface for all registers within the entire register-module structure. The fundamental concept underlying the Driver module revolves around consolidating multiple INC and DEC pins into a single pair, accompanied by a CLK (clock) input.

When both INC and DEC signals maintain identical voltage states (either low or high), the selected register operates in a mode referred to as "none" during the rising edge of the CLK. This signifies that the register's value remains unchangedâ€”neither incremented nor decremented. Conversely, when the digital value of the INC-DEC pair registers as 01 or 10, the corresponding selected register experiences either an increment or a decrement in its value.

The output generated by the Driver module, in the form of the UP-DOWN signal pair, directs the appropriate action to the designated register. Notably, for registers utilizing the 74LS161 chip that exclusively permits incrementing, only an UP signal is necessary.

To facilitate register selection, a selecting interface is imperative to designate the specific register under manipulation. The inner circuitry (refer to figure \ref{fig:registerModuleOverview}) adeptly fulfills this function. The accompanying figure provides a broad overview of the register-module, showcasing the existence of three select pins capable of establishing eight distinct paths. This suffices, given the presence of fewer than eight unique registers within the system's architecture.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/register_module_overview}
	\caption{Register-module Overview}
	\label{fig:registerModuleOverview}
\end{figure}

\subsubsection{74LS193 Chaining}
The utilization of 74LS193 (or 74LS161) chips in the construction of registers provides both storage capacity and INC-DEC functionality. However, a singular 74LS193 chip inherently provides storage for 4 bits, which falls short of the 8 or 16 bits necessary for the registers' intended functionality. Fortunately, the 74LS193 chip offers a chaining capability, mitigating this limitation.

Through a chaining configuration wherein the Carry-Out (CO) of one chip connects to the Up (UP) pin of another, and the Borrow Out (BO) links to the Down (DOWN) pin, an expansion of available bits becomes feasible (refer to figure \ref{fig:registerModuleChaining}). This method effectively extends the storage capacity, enabling the aggregation of multiple chips to accommodate the required bit sizes. This chaining technique stands as a foundational element implemented across registers demanding more than 4 bits, ensuring their requisite storage depth and functionality.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/register_module_chaining}
	\caption{Register-module 74LS193 chaining}
	\label{fig:registerModuleChaining}
\end{figure}

\subsubsection{Circuit: Driver Module}

In the computer's initial design phase, various concepts were explored for implementing this module. Initially, the demux-circuit was incorporated; however, it exhibited partial functionality, encountering persistent issues such as potential propagation delays and compatibility concerns with the 74LS193 chip. Resolving these issues in a sustainable and efficient manner posed considerable challenges.

Consequently, the decision was made to discard the initial driver module design (refer to Appendix A(\ref{sec:appendix:old_driver_module_design}) for an in-depth exploration of the former circuitry) in favor of developing an alternative circuit. This revised circuit now stands as the official and integral component of the computer's architecture, addressing the shortcomings and inefficiencies encountered in the prior design iteration.

The concept underlying the development of this stable driver module is rather straightforward:
\begin{itemize}
	\item Configure UP-DOWN\footnote{The output of the driver module} to a HIGH state when both INC and DEC signals are either high or low simultaneously.
	\item Generate a pulse on the UP signal while maintaining the DOWN signal high when INC is high and DEC is low.
	\item Generate a pulse on the DOWN signal while maintaining the UP signal high when INC is low and DEC is high.
\end{itemize}

The practical implementation details are visually represented in Figure \ref{fig:actual_driver_module_implementation}, accompanied by the following corresponding solutions:

\begin{itemize}
	\item Common Interface:
	\begin{itemize}
		\item Utilize $$CLK + (INC \oplus DEC)$$ to prevent pulsing when INC and DEC have identical values.
		\item Connect the resultant signal with the inverted INC-DEC into a NAND gate to ensure favorable behavior when INC and DEC have different values.
		\item Integration of additional inverters is imperative to ensure compatibility with both the registers and the select interface\footnote{The 3-to-8 demultiplexer used inverts the output}.
	\end{itemize}
	\item Select Interface:
	\begin{itemize}
		\item Establish connection of the UP-DOWN pair to the 3-to-8 demultiplexer, facilitating the routing of this pair to the input of the selected register.
	\end{itemize}
\end{itemize}


\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/actual_driver_module_implementation}
	\caption{The Actual Driver Module Implementation}
	\label{fig:actual_driver_module_implementation}
\end{figure}



\subsubsection{Circuit: Data Register}
The data register functions as an 8-bit valued flip-flop, equipped with both increment and decrement functionalities, which led to the adoption of the 74LS193 chip. An integral feature of the data register is its generation of a zero flag (Z), indicating a value of 1 exclusively when the stored value within the register is 0. The implementation of this particular feature involves the use of OR gates and direct connections to the stored bits (refer to Figure \ref{fig:dataRegisterImplementation} for a visual representation).


\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/data_register_implementation}
	\caption{Data, and Loop-Skip Register Implementation (\ref{sec:implementation:registers:loop_skip})}
	\label{fig:dataRegisterImplementation}
\end{figure}


\subsubsection{Circuit: Data-Pointer Register} \label{sec:implementation:registers:dpreg}
The Data-Pointer register operates as a 16-bit valued flip-flop equipped with both increment and decrement functionalities, consequently utilizing the 74LS193 chip. While the Data-Pointer register itself holds no distinct exceptional properties, its output (the stored value) maintains a connection to the bus transceiver, a characteristic shared among other registers as well\footnote{The implementation of the bus transceiver involves a straightforward approach: connecting only outputs alongside the DIR and CE (chip enable) pins as inputs, employing the 74LS245 chips}. Refer to Figure \ref{fig:dataPointerRegisterImplementation} for an illustrative depiction of its implementation.

\subsubsection{Circuit: Stack-Pointer Register} \label{sec:implementation:registers:spreg}
The Stack-Pointer register operates as a 8-bit valued flip-flop equipped with both increment and decrement operations. Comparing with the DP-Reg, the SP-Reg could have been implemented in the same way. Thus, instead of using four 74LS193 chips for DP-Reg, only two chips were sufficient. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/data_pointer_register_implementation}
	\caption{Data-Pointer Register Implementation}
	\label{fig:dataPointerRegisterImplementation}
\end{figure}

\subsubsection{Circuit: Loop-Skip Register} \label{sec:implementation:registers:loop_skip}
At its core circuitry, the loop-skip register (LS-R) shares an identical implementation with the data register (D-R): both possess an 8-bit storage capacity, facilitate increment and decrement operations, and include a loop-flag functionality\footnote{The loop-flag mirrors the zero-flag in the data register, thus is implemented in a similar fashion as in the data register}. For an illustration of this implementation, please refer to Figure \ref{fig:dataRegisterImplementation}.


\subsubsection{Circuit: Instruction Register} \label{sec:implementation:registers:instruction}
As stated above for Loop-Skip Registers, the instruction register shares an identical implementation with the data register: both possess an 8-bit storage capacity. However, an internal circuitry contains 74LS173 chips instead of 74LS193. The underlying reason is derived from unnecessary decrement functionality \footnote{Instruction Register stores current operation machine code, which can only be loaded from the ROM}. We will dive deeper in \ref{sec:control_unit}.

\subsubsection{Circuit: Instruction-Pointer Register}
The instruction-pointer register (IP-R) shares its implementation framework with the data-pointer register. However, as the IP-R specifically denotes the machine code's location stored in the ROM, its sole requirement is for increment functionality. The procedural nature of brainf*ck dictates sequential code processing. Consequently, rather than utilizing the 74LS193, the choice fell upon the 74LS161 chip for its capacity to exclusively handle increments.

\subsubsection{Circuit: Flag Register}
The Flag Register is designed to manage precisely two bits, functioning as a 2-bit latch. Notably, our available inventory comprises chips configured for 4-bit operations, hence, two additional bits within the Flag Register remain reserved for potential future modifications. For this purpose, the LS74173 chip was selected to serve as the Flag Register. 


\subsection{Memory} \label{sec:implementation:memory}
\subsubsection{RAM} \label{sec:implementation:memory:ram}
In our architecture, we utilized 16-bit address, 8-bit word RAM chip (AS6C4008). Important to note, because some cells will need a bigger value than 8-bit, two RAMs are chained together with addresses and control pins connected. First 256 words with address from 0 to 255 store stack values pointed by the stack pointer. All other words are data in individual BF-cells pointed by data-pointer. Therefore, it was necessary to combine DP-Reg (see \ref{sec:implementation:registers:dpreg}) and SP-Reg (see \ref{sec:implementation:registers:spreg}). The problem was that we cannot hard-connect the output of two pointers directly to the address lines of the RAM chip since it would cause voltage interference, and other hard to debug, impaired functionality. The solution was to use several 8-bit bus transceivers (see \ref{fig:ram_buffer}).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/ram_buffer}
	\caption{RAM and 8-bit bus transceivers}
	\label{fig:ram_buffer}
\end{figure}

Firstly, let us explore the reasoning how to split two pointers. SP-Reg has 8 bits whereas DP-Reg has 16 bits. Suppose we connect DP-Reg directly to the address lines of the RAM chip. Then, add SP-Reg's 8-bits of output to the first eight address lines of the RAM. In this configuration, if both registers output voltage simultaneously, voltage interference happens as high and low bias equals high bias. The first step is to connect the output of both pointers to the bus transceivers (from now on we use the abbreviation nBT8 for n 8-bit bus transceivers): SP-Reg---1BT8, and DP-Reg---2BT8. Control Unit can either activate a BT8 or disable for the pointer registers. Control unit must not activate both BT8s at the same time to prevent voltage interference.

From the first sight, it may be reasonable to state that this is a complete solution. However, the problem arises when we try to output SP-Reg: first 8-bit address lines have correct input from the register while other 8-bit address lines (remember that the RAM has sixteen address lines) are noise, as they are connected to the disabled BT8 of the DP-Reg. Therefore, we required to ground these 'higher,' disabled 8-bits of address lines. Another bus was introduced, right in the vicinity of the RAM with all the values connected to the ground. We call it the GND-Reg. The necessity to introduce a new bus rather than connect the values to the ground was interference with DP-Reg input - we do not want higher 8-bits to be always at the low potential. On this point, address lines are properly configured. The complete picture you can see in \ref{fig:ram}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/ram}
	\caption{Encapsulated overview of RAM}
	\label{fig:ram}
\end{figure}

Now, we can shed light on the output of the RAM. The chip that we are using have three control pins: Write-Enable (WE), Output-Enable (OE), and Chip-Enable (CE). The map of possible combinations and corresponding actions you can see in the official data-sheet for AS6C4008. Depending on the combination of WE, OE, and CE, BT8s of SP-Reg, DP-Reg, and GND-Reg must be configured appropriately. In particular, its direction and output-enable pin. This was done by several elongated wires that you can see in figure \ref{fig:ram:elongated_wires}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/elong_wires_ram}
	\caption{Elongated wires of RAM}
	\label{fig:ram:elongated_wires}
\end{figure}

When RAM outputs the data, it must be stored in the D-Reg and IP-Reg. However, since the two RAMs output 16-bit value, D-Reg is not able to store all 16-bits of information. Therefore, we divided 16-bit RAM output in higher and lower 8-bit values (HV AND LV for compactness). HV and LV are connected to two BT8s. The principle is actually the same as we dealt with address lines. One BT8 is connected to ground, the second to D-Reg, and, finally, both are connected to the IP-Reg for loading. Proper configuration of BT8's direction and output-enable pins is necessary, so proper wires have been added\footnote{if you would like to know the location of these configuration wires, you can search them in the real circuit or in the photos provided in Appendix B}.

\subsubsection{ROM} \label{sec:implementation:memory:rom}
...


\subsection{Control Unit} \label{sec:implementation:control_unit}
For the proper functionality of the Control Unit (see \ref{sec:control_unit:working_principle}), it requires two 4-bit unary counters, particularly cycle counter (CC) and bank counter (BC), and three 8-bit registers that we refer to as CUR1, CUR2, and CUR3 (or just CUR(s)). While all counters and registers are not chained and are the same in implementation, we provide the reader with the implementation of one counter and one register.

\subsubsection{CUR - Control-Unit Register} \label{sec:implementation:control_unit:cur}
Each CUR only needs to be able to load 8-bit data, reset, and to have a 3-state buffer\footnote{That is, to have Output-Enable pin.}. Luckily, we have this 4-bit 3-state flip-flop covered in one conventional chip, 74LS173. Two chips are chained together with OE and address lines connected. The abstract circuit and breadboard implementation you can observe in the figures below and \ref{fig:cu_diagram}.


\begin{figure}[H]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/progress/8}
		\caption{CURs on breadboard 1}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/curs}
		\caption{CURs on breadboard 2}
	\end{minipage}
\end{figure}


\subsubsection{Counters} \label{sec:implementation:control_unit:counters}
The counter needs to count in this order: 00 --- 01 --- 10 --- 11 --- 00. It should have reset and output pin. Luckily, our inventory did contain a conventional chip with appropriate logic, 74LS161. Because the circuit is not complicated, we provide you with the abstract circuit and the real one, which you can find in the figures below.

\begin{figure}[H]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/counters}
		\caption{Counters on breadboard}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/curs}
		\caption{Counters - circuit}
	\end{minipage}
\end{figure}


\subsection{Input} \label{sec:implementation:input}
...

\subsection{Output} \label{sec:implementation:output}
...
