\section{Implementation} \label{sec:implementation}
This section will discuss the implementation of each module and the way they integrate together to make the computer. Figure \ref{fig:computer} shows the computer as it was in February 2025. The overlays shown in Figure \ref{fig:computer_parts} distinguish each of the modules described in previous sections.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/placeholder}
  \caption{Prototype as of February 2025.}
  \label{fig:computer}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/placeholder}
  \caption{Overview of the different parts of the computer.}
  \label{fig:computer_parts}
\end{figure}

%%%%%%% CLOCK

\subsection{Clock Module} \label{sec:clock}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{img/placeholder}
  \caption{Close up of the Master Clock and Reset/Resume Modules.}
  \label{fig:masterclockcloseup}
\end{figure}

The clock module is located at the bottom right of the computer and is responsible for providing a heartbeat to most of the modules. The design of the clock is taken directly from Ben Eater's 8-bit computer video's \cite{beneater}. The automatic clock is generated by a 555 timer in astable mode. A set of DIP switches is used to select the capacitor of the RC-circuit that determines the output frequency for coarse control and a 100K linear potentiometer is used for fine control of the clock frequency. Two additional 555 timers are used to debounce both the pushbutton for the manual clock and the latching push button which acts as a select between the two modes, as per Ben's design. 

The frequency of the astable 555 is halved by sending it through a JK flip-flop to ensure a perfectly symmetric duty cycle, then fed into divided into a 74LS123 monostable multivibrator to produce two short 200ns pulses: one on the rising and another on the falling edge the output of the flip-flop. This results in two sets of clean signals at constant intervals. On the first pulse (rising edge of the original clock), the control signals are loaded from the microcode EEPROMs into their registers (which connected to the modules), while the second pulse is connected to the modules to act upon. This approach guarantees a clean division between setting the control signals and clocking the modules. Figure \ref{fig:clocktiming} shows the timing diagram for the different signals discussed above.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{img/clocktiming}
  \caption{Timing diagram for the clock signals.}
  \label{fig:clocktiming}
\end{figure}

\subsubsection{Frequency Control}
Details about the frequency control system here.

\subsubsection{Frequency Display}
Details about the frequency display here.


\subsection{Reset/Resume} \label{sec:resetresume}
The Reset/Resume module is located directly underneath the clock and contains logic necessary to be able to reset the computer (necessary after applying power) and resuming the clock after it has been halted. The HLT signal coming from the decoder is latched into a register (74LS173) from which the corresponding output bit is connected to the HLT input of the clock module. When the system is reset (using the reset button) or when the resume button is pressed, the HLT bit is cleared and the clock resumes. This allows for pausing and resuming the computer, effectively adding breakpoints in the code. The reset button itself is debounced in the same way as the manual clock button to ensure a stable transition with a debounce time of around 300ms.

The Resume button needs more sophisticated debounce circuitry due to the following scenario: when multiple HLT instructions are seperated by a relatively small amount of other instructions, a pulse in the order of milliseconds (like the reset and pulse debouncers) will be far too long at high clock frequencies. The resume-signal will still be high when a second (or third, fourth, ...) HLT instruction is encountered, causing control flow to simply skip over these instructions. To remedy this situation, a debouncing circuit is required that first produces a pulse of equal width of the clock pulses (Figure \ref{fig:clocktiming}), followed by a guaranteed period where the signal is low, even when the button bounces after the pulse. This is achieved by creating a feedback loop between the two monostable vibrators present on the 74LS123. The first one will produce a 200ns pulse on the rising edge of the button. This pulse is sent to the reset of the register that holds the HLT signal in order to clear it, but is also connected to the second monostable vibrator. When the initial (short) pulse goes low, the second vibrator generates a much longer pulse that is connected to the reset-input of the first one, making sure it cannot be re-activated for some time. By selecting a 680K resistor and a 4.7$\mu F$ capacitor, a cooldown period of around a second is achieved. Figure \ref{fig:resumedebounce} shows a timing diagram to illustrate this process in more detail. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{img/resumedebounce}
  \caption{Timing diagram for the resume debouncer.}
  \label{fig:resumedebounce}
\end{figure}


\subsubsection{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/masterclock.pdf}

%%%%%%% REGISTER DRIVER

\subsection{Register Driver} \label{sec:implementation:registerdriver}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{img/placeholder}
  \caption{Close up of the Register Driver Module.}
  \label{fig:registerdrivercloseup}
\end{figure}
The register driver is responsible for sending the correct signals to the counting input of the D, DP, SP, IP and LS registers. All of these are based around the 74LS193, which has a U and D input and requires one of them to be pulsed low in order to execute the corresponding action. For example, to decrement this register, a low pulse must be sent to the D input while U is kept high. As explained in section \ref{sec:architecture:controlunit}, we used a centralized driver to limit the number of logic IC's necessary to drive the registers and the total number of control signals necessary.

\subsubsection{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/registerdriver.pdf}

%%%%%%% DATA POINTER REGISTER

\subsection{DP Register Module}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{img/placeholder}
  \caption{Close up of the Data Pointer Register Module.}
  \label{fig:dpregcloseup}
\end{figure}

The datapointer register contains the address of the cell currently being operated on. It is a 16 bit value kept in four 74LS193 IC's because of the requirement that is should be able to be incremented and decremented. Their outputs are connected to the address bus through a pair of tristate buffers to prevent bus contention with the stack pointer. Because the first 256 bytes are reserved as the stack (where instruction pointer values can be stored to implement loops), the reset value of this register should be set to 0x0100. This is achieved by resetting all IC's except for the one containing the 3rd nibble, which is reset to one by hardcoding 0x1 to its inputs and connecting the reset line (through an inverter) to the load-pin instead.

This register is special in the sense that it is the only register that should be able to be reset at runtime seperately from all the other modules (through the DPR signal). This allowes it to be reset to its starting value after initializing the computer when power is first applied (see also Sections \ref{sec:sequences:init} and \ref{sec:sequences:home}). The RESET signal is therefor fed into an OR gate together with the DPR signal before going to the reset pins of the IC's.

Perhaps somewhat confusingly, the schematic (see next page) shows that the SP\_EN signal is used to enable the buffers. Since the bus is shared only between the stack pointer and data pointer, the same signal can be used to enable and disable their respective buffers: when the stack pointer is enabled, the data pointer should be disabled and vice versa. Since the output enable pin of the 74LS245 is active low, the SP\_EN can be fed directly into it. On the side of the stack pointer, the same signal goes through an inverter before going into the buffer. By default, when the stack pointer is not enabled, the datapointer will provide the address to the RAM. The RAM address input lines will never be floating which means that the contents of the current memory cell (in RAM) will always be visible in the computer.



\subsubsection{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/datapointerregister.pdf}


%%%%%%% DATA REGISTER

\subsection{D Register Module}
\begin{figure}[H]
  % TODO: add annotations to the image
  \centering
  \includegraphics[width=0.6\textwidth]{img/placeholder}
  \caption{Close up of the Data Register Module.}
  \label{fig:dregcloseup}
\end{figure}

The data register holds (a copy of) the value in memory currently pointed to by the datapointer. In the computer, it is located in the top left corner. It is based around the 74LS193 counting register and driven by the register driver described in Section \ref{sec:implementation:registerdriver}. The output is buffered in a tristate buffer (74LS245) before being connected to the databus. A second buffer is used to send all zeroes to the high byte of the databus since the data is only 8 bits wide. The buffers are set to output-mode only (even though the register is able to read from the bus as well) because the 74LS193 chips have seperate pins for incoming and outgoing data. The incoming data is read from the bus directly without going through a buffer.

This module also produces the Z flag, indicating that it is currently containing the value 0. This is achieved by sending the output through an array of OR gates and finally an inverter. The output is then sent to the second half of the instruction register which is responsible for keeping track of the flags.

Because the 74LS193 is loading asynchronously, the clock is gated together with the LD\_D signal through a NAND gate in order to load synchronously with the clock when the LD\_D signal is high (the load-pin on the '193 is active low). The necessity of a NAND gate meant it was easier to also implement any inverters needed in the circuit in terms of NAND gates.


\subsubsection{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/dataregister.pdf}

%%%%%%% INSTRUCTION POINTER REGISTER

\subsection{IP Register Module}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{img/placeholder}
  \caption{Close up of the Instruction Register Module.}
  \label{fig:iregcloseup}
\end{figure}

The instruction pointer register holds a 16-bit value representing the address of an instruction in program-memory, stored in an EEPROM module (see \ref{sec:implementation:sigfetch}). Because the size of the available address space is $2^{14}$ instructions, the final two bits of the IP are not used. Red LEDs have been connected to these bits to quickly identify programs that try to address this non-existing part of program memory. The register IC's (74LS193) are driven by the register driver.

The IP is connected to the databus through two tristate buffers (74LS245) to avoid bus contention with the datapointer and keyboard module. It needs to be connected to this bus in order to write its value to the stack when a loop is entered. When exiting from a loop, a value is read back into the register through a direct connection to this bus (without going through a buffer). Because loading is done asynchronously on the '193, the load signal is NAND'ed with the clock to make loading synchronous again.

\subsubsection{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/instructionpointerregister.pdf}

%%%%%%% STACK POINTER REGISTER

\subsection{SP Register Module}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{img/placeholder}
  \caption{Close up of the Stack Pointer Register Module.}
  \label{fig:spregcloseup}
\end{figure}

The stack pointer is an 8 bit value representing a memory address in the range 0x00 - 0xff, which has been reserved to hold instruction pointer values. This is necessary for implementing conditional loops. When a loop is entered, the current value in the IP register is stored on the stack at the address pointed to by the stack pointer. The SP module is therefore connected to the same RAM address bus as the datapointer, which means it should go through a tristate buffer to avoid bus contention.


\subsubsection{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/stackpointerregister.pdf}


%%%%%%% CONTROL UNIT

\subsection{Control Unit}
\subsubsection{Partitioning}
The control unit is responsible for sending the appropriate signals to each of the modules. The general idea is that the current instruction pointed to by the IP (4 bits) together with the state flags (another 4 bits: A, V, S and Z) and the cycle count (3 bits) combine together to form an (11 bit) address into an EEPROM chip (AT28C64B) which contains the signal configuration for this state. The problem with this approach however is that the control unit needs to be able to drive 22 different control signals (for a complete list, see \ref{sec:architecture:cu}) or the schematic below), which cannot all be stored at a single 8-bit address in the EEPROM. There are two solutions to this problem:
\begin{enumerate}
\item Use 3 EEPROM chips, each containing a set of 8 signals (maximum). This allows for 24 different signals to be stored and retrieved efficiently in the same clock cycle.
\item Use 1 EEPROM chip and partition its memory space using its two unused address bits (the EEPROM has 13 address lines of which we so far needed only 11 to encode the state of the computer). In this case, additional logic and additional read-cycles are needed to gather the different parts of the control signal configuration.
\end{enumerate}

At the time of designing this processor, the AT28C64B was in very short supply and we were only able to find a single chip for use in the prototype. This forced us to implement method 2 at the cost of burning additional clock cycles to retrieve each of the three parts of the signal configuration. Even though this approach results in a significantly slower computer, it is an elegant solution in the sense that all of the microcode information is stored in a single place. It also somewhat simplified the testing process because we only had to reprogram a single EEPROM every time the microcode table turned out to contain an error, rather than 3 different chips (see \ref{sec:implementation:programmer} for details on how these chips are programmed).

Based on the physical layout of the board, the following configuration was used to partition the EEPROM:
\\
\begin{center}
\begin{tabular}{r|ll} 
  Address Bits & \\ \hline
  0-2  & Cycle count & ($000_2$ - $111_2$) \\
  3-4  & Partition number & ($00_2$ - $11_2$) \\
  5-8  & Instruction & ($0000_2$ - $1111_2$) \\
  9-12 & Flags & ($0000_2$ - $1111_2$) \\
\end{tabular}
\end{center}

\subsubsection{Clock Divider}
Due to the partitioning strategy, the master clock needs to be divided into 4 subclocks. On the first 3 subclock pulses, each of the control signal configuration parts is loaded into an 8-bit partition register, connecting to the modules that expect the corresponding signals. A pulse from the fourth subclock is then sent to all of the modules to execute their functions. 

To implement the clock divider, a single 4-bit counting register (74LS161) is connected to address bits 3 and 4 of the EEPROM and to demultiplexer (74LS138). The first 3 outputs of the demultiplexer produce the first 3 subcycle pulses which are sent to 3 sets of two 4-bit registers (also 74LS161 with counting disabled), which will store each of the configuration parts. A '161 will load the value at its input reliably when the load-pin is active before receiving a pulse from the clock. This is why the outputs of the '138 are directly connected to the load-pins but also negated and AND'ed with the clock to produce a pulse offset by a half-cycle on the clock pins of the '161s (Figure \ref{fig:partitioning}). The fourth output of the demux is used as the clock signal for all the other modules (CLK) and to reset the count of the '161 that is responsible for keeping track of the partition numbers to make it loop back to 0, restarting the process for the next instruction.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{img/partitioning}
  \caption{Timing diagram of the signals going from the clock divider to the load and clock pins of the partition registers (load pins are active low on the 74LS161).}
  \label{fig:partitioning}
\end{figure}

\subsubsection{Program ROM}
The actual BF program is stored in another 8K EEPROM chip (AT28C64) and is addressed by the instruction pointer as mentioned before. Since each BF instruction only needs 4 bits to be encoded (there are less than 16 different instructions), we can store up to 16K instruction in the chip by packing 2 consecutive instructions together in a single byte (handled by the assembler). Rather than using bit 0 from the IP directly as address bit 0 on the EEPROM, it is used as the data-select signal to a 74LS157 multiplexer. This multiplexer takes 1 select-bit and two sets of 4 databits. Depending on the value of the select-bit, one of the sets of 4-bit data is sent to its outputs. This allowes us to select either the low or high nibble of the data in the EEPROM, effectively doubling the amount of instructions that can be stored and retrieved.

\subsubsection{Instruction and Flag Register}
The instruction register acts as a buffer to store the current state of the system (current instruction + flags). It is connected to the output of the '157 described above, to the S and Z flags produced by the D and LS registers, and finally to the outputs of the flag register. The flag register gets its inputs directly from the control signals in order to buffer the A and V flag, which may be set at any cycle of an instruction and must be remembered until the next instruction (only 2 of its 4 bits are used).

\subsubsection{Cycle Counter}
The cycle counter is another 74LS161 that simply counts up and sends its outputs (bits 0-2) to address lines 0-2 of the microcode EEPROM. It is reset when it receives the CR signal. Rather than using a regular inverter, a Schmitt Trigger was used on its clock input to stabilize counting.


\subsubsection{Schematic}
Full schematics are provided on the next pages (divided into 2 parts).
\includepdf[landscape=true]{schematics/controlunit1.pdf}
\includepdf[landscape=true]{schematics/controlunit2.pdf}
