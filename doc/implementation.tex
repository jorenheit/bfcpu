\section{Implementation} \label{sec:implementation}
This section will discuss the implementation of each module and the way they integrate together to make the computer. Figure \ref{fig:computer} shows the computer as it was in January 25, which was its first working state. In Figure \ref{fig:computer_parts} the overlays show where each of the modules are located.

\begin{figure}[H]
  \centering
  % TODO: high resulotion version
  \includegraphics[width=0.9\textwidth]{img/computer}
  \caption{Prototype in January 2025.}
  \label{fig:computer}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{img/computer_parts}
  \caption{Overview of the different parts of the computer.}
  \label{fig:computer_parts}
\end{figure}

%%%%%%% CLOCK

\subsection{Master Clock and Reset/Resume} \label{sec:clock}
\begin{figure}[H]
  % TODO: add annotations to the image
  \centering
  \includegraphics[width=0.6\textwidth]{img/masterclockcloseup}
  \caption{Close up of the Master Clock and Reset/Resume Modules.}
  \label{fig:masterclockcloseup}
\end{figure}

The Master Clock module (MC) is located at the bottom right of the computer and is responsible for providing a heartbeat to most of the modules. The design of the clock is taken directly from Ben Eater's 8-bit computer video's \cite{beneater}. The automatic clock is generated by a 555 timer in astable mode. A 1M linear potentiometer is used together with a 1$\mu$ capacictor to control the frequency. Two additional 555 timers are used to debounce both the pushbutton for the manual clock and the latching push button which acts as a select between the two modes, as per Ben's design. 

The reason this module is called \emph{Master} Clock (rather than just Clock) is that the output of this module is not serving directly as the clock to all of the modules. For reasons becoming apparent when the implementation of the decoding process is discussed (see \ref{sec:implementation:clockdivider}), this clock is divided into 4 subclock-pulses, the last of which is sent to the modules. Effectively,  the frequency at which the computer operates is only one fourth that of the output from the MC.

The Reset/Resume module is directly underneath the clock and contains some logic to be able to reset the computer (necessary after applying power) and resuming the clock when it is halted. The HLT signal coming from the decoder is latched into a register (74LS173) from which the corresponding output bit is connected to the HLT input of the Master Clock selection logic. When the system is reset using the reset button or when the resume button is pressed, the HLT bit is cleared and the clock resumes. This allows for pausing and resuming the computer, effectively adding breakpoints in the code. The reset button itself is debounced in the same way as the manual clock button to ensure a stable transition. 

\subsubsection*{Stability}
When the output of the clock was first connected a counting register within the clock divider, it turned out that its output signal was too noisy for reliable operation of the counter. This register (74LS161) is sensitive to even very short pulses and the logic responsible for selecting either the automatic clock or the manual pulses was adding too much noise. The selection logic was modified to use a Schmitt Trigger (74LS14) at its output (rather than a regular inverter like the 74LS04) to improve output signal quality. A Schmitt Trigger acts as an inverter with different thresholds for each direction of inversion. This means it will invert any incoming signal above some voltage threshold but when the input goes below that same threshold shortly after due to noise, it will not change its output again until the signal drops significantly. Once the Schmitt Trigger was implemented, all stability issues went away.

\subsubsection*{Parts}
\begin{itemize}\itemsep0em
\item 4x NE555P (555 Timer)
\item 1x 74LS14 (Schmitt Trigger Inverter)
\item 1x 74LS00 (NAND)
\item 1x 74LS173 (4 bit register)
\item 1x 74LS32 (OR)
\item 4x $0.01\mu F$ ceramic capacitor
\item 3x $1\mu F$ capacitor
\item 3x tactile switch
\item 1x latching push button
\item 1x potentiometer (0-1M)
\item 6x 1K resistor
\item 1x 200K resistor
\item 1x 470K resistor
\end{itemize}

\subsubsection*{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/masterclock.pdf}

%%%%%%% REGISTER DRIVER

\subsection{Register Driver} \label{sec:implementation:registerdriver}
\begin{figure}[H]
  % TODO: add annotations to the image
  \centering
  \includegraphics[width=0.6\textwidth]{img/registerdrivercloseup}
  \caption{Close up of the Register Driver Module.}
  \label{fig:registerdrivercloseup}
\end{figure}
The register driver is responsible for sending the correct signals to the counting input of the D, DP, SP, IP and LS registers. All of these are based around the 74LS193, which has a U and D input and requires one of them to be pulsed low in order to execute the corresponding action. For example, to decrement this register, a low pulse must be sent to the D input while U is kept high. As explained in section \ref{sec:architecture:controlunit}, we used a centralized driver to limit the number of logic IC's necessary to drive the registers and the total number of control signals necessary.

To limit the number of IC's, we chose to use NAND-gates instead of inverters and AND-gates. The truth table for this logic is shown in Table \ref{tab:registerdrivertruth}.

\begin{table}[h]
  \centering
  \begin{tabular}{ccc|cc|l}
    INC & DEC & CLC & U & D & Effect \\ \hline
    0   & 0   & 0   & 1 & 1 & - \\
    0   & 0   & 1   & 1 & 1 & - \\
    0   & 1   & 0   & 1 & 1 & - \\
    0   & 1   & 1   & 1 & 0 & Low pulse on D: decrement active register. \\
    1   & 0   & 0   & 1 & 1 & - \\
    1   & 0   & 1   & 0 & 1 & Low pulse on U: increment active register \\
    1   & 1   & 0   & 1 & 1 & - \\
    1   & 1   & 1   & 1 & 1 & - \\
  \end{tabular}
  \caption{Truth table for the register driver logic in order to comply with the 74LS193 counting registers.}
  \label{tab:registerdrivertruth}
\end{table}

The Register Driver takes 3 select-bits (control signals coming from the decoder) together with an INC and DEC signal and the clock (not the MC). The logic as seen in the schematic on the following page is responsible for providing the U and D inputs to the 74LS193 counters, each of which are sent to a demultiplexer (74LS138). The aforementioned register select signals are used to index these chips and address the appropriate registers (see also Table \ref{tab:registers}).

\subsubsection*{Parts}
\begin{itemize}\itemsep0em
\item 2x 74LS00 (NAND)
\item 1x 74LS86 (XOR)
\item 2x 74LS138 (3-to-8 demultiplexer)
\end{itemize}

\subsubsection*{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/registerdriver.pdf}

%%%%%%% DATA POINTER REGISTER

\subsection{DP Register Module}
\begin{figure}[H]
  % TODO: add annotations to the image
  \centering
  \includegraphics[width=0.6\textwidth]{img/dpregcloseup}
  \caption{Close up of the Data Pointer Register Module.}
  \label{fig:dpregcloseup}
\end{figure}

The datapointer register contains the address of the cell currently being operated on. It is a 16 bit value kept in four 74LS193 IC's because of the requirement that is should be able to be incremented and decremented. Their outputs are connected to the address bus through a pair of tristate buffers to prevent bus contention with the stack pointer. Because the first 256 bytes are reserved as the stack (where instruction pointer values can be stored to implement loops), the reset value of this register should be set to 0x0100. This is achieved by resetting all IC's except for the one containing the 3rd nibble, which is reset to one by hardcoding 0x1 to its inputs and connecting the reset line (through an inverter) to the load-pin instead.

This register is special in the sense that it is the only register that should be able to be reset at runtime seperately from all the other modules (through the DPR signal). This allowes it to be reset to its starting value after initializing the computer when power is first applied (see also Sections \ref{sec:sequences:init} and \ref{sec:sequences:home}). The RESET signal is therefor fed into an OR gate together with the DPR signal before going to the reset pins of the IC's.

Perhaps somewhat confusingly, the schematic (see next page) shows that the SP\_EN signal is used to enable the buffers. Since the bus is shared only between the stack pointer and data pointer, the same signal can be used to enable and disable their respective buffers: when the stack pointer is enabled, the data pointer should be disabled and vice versa. Since the output enable pin of the 74LS245 is active low, the SP\_EN can be fed directly into it. On the side of the stack pointer, the same signal goes through an inverter before going into the buffer. By default, when the stack pointer is not enabled, the datapointer will provide the address to the RAM. The RAM address input lines will never be floating which means that the contents of the current memory cell (in RAM) will always be visible in the computer.

\subsubsection*{Parts}
\begin{itemize}\itemsep0em
\item 1x 74LS04 (NOT)
\item 1x 74LS32 (OR)
\item 4x 74LS193 (Up/Down Counting Register)
\item 2x 74LS245 (Tristate Buffer)
\end{itemize}


\subsubsection*{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/datapointerregister.pdf}


%%%%%%% DATA REGISTER

\subsection{D Register Module}
\begin{figure}[H]
  % TODO: add annotations to the image
  \centering
  \includegraphics[width=0.6\textwidth]{img/dregcloseup}
  \caption{Close up of the Data Register Module.}
  \label{fig:dregcloseup}
\end{figure}

The data register holds (a copy of) the value in memory currently pointed to by the datapointer. In the computer, it is located in the top left corner. It is based around the 74LS193 counting register and driven by the register driver described in Section \ref{sec:implementation:registerdriver}. The output is buffered in a tristate buffer (74LS245) before being connected to the databus. A second buffer is used to send all zeroes to the high byte of the databus since the data is only 8 bits wide. The buffers are set to output-mode only (even though the register is able to read from the bus as well) because the 74LS193 chips have seperate pins for incoming and outgoing data. The incoming data is read from the bus directly without going through a buffer.

This module also produces the Z flag, indicating that it is currently containing the value 0. This is achieved by sending the output through an array of OR gates and finally an inverter. The output is then sent to the second half of the instruction register which is responsible for keeping track of the flags.

Because the 74LS193 is loading asynchronously, the clock is gated together with the LD\_D signal through a NAND gate in order to load synchronously with the clock when the LD\_D signal is high (the load-pin on the '193 is active low). The necessity of a NAND gate meant it was easier to also implement any inverters needed in the circuit in terms of NAND gates.

\subsubsection*{Parts}
\begin{itemize}\itemsep0em
\item 1x 74LS00 (NAND)
\item 2x 74LS32 (OR)
\item 2x 74LS193 (Up/Down Counting Register)
\item 2x 74LS138 (3-to-8 demultiplexer)
\end{itemize}

\subsubsection*{Schematic}
A full schematic is provided on the next page.
\includepdf[landscape=true]{schematics/dataregister.pdf}









