\section{Conclusion} \label{sec:conclusion}
\subsection{Retrospective}
Building Synapse-191 has been a tremendously powerful learning experience. Above all, the joy of seeing months of tedious work, planning and debugging culminate into a working system is unparalleled. Even though the system is not fully stable at all times (in some programs less so than in others), it works well enough to demonstrate that it does the job it was designed to do in principle. The system's specifications itself never prevented any of the tested BF programs to run; it was never low on memory, has a large enough program-ROM to store BF code and has plenty of stack-space to run even computationally demanding programs. Features like the IO system, being able to store multiple programs to select from, single-stepping and easy control of the clock make it an enjoyable process to operate the computer. Moreover, with the toolchain developed to a mature state, adding features through modification of the firmware and microcode was relatively straightforward and thoroughly rewarding to do. During development, various ideas and opportunities for potential improvement came to mind, some of which are listed in the sections below.

\subsection{Final Thoughts and Potential Improvements}
\paragraph{Virtual Registers} A big limitation of using the register driver as a centralized system to increment or decrement each register is the fact that only one register can be addressed per clock cycle. Having two addresses on the register driver still unconnected (addresses 110 and 111), their corresponding outputs could be connected to multiple registers that commonly need to increment together. For example, address 110 (bits RS2 and RS1) would then correspond to the virtual register D/IP. The corresponding U and D output signals would then be connected (through OR gates) to the counting inputs of both the D and IP register. Addressing this virtual register would then allow for incrementing or decrementing these registers simultaneously, which saves a clock cycle in the PLUS instruction. The MINUS instruction does not benifit from this trick, since we can't both decrement D and increment IP at the same time. The same could be done for DP and IP, saving a clock cycle in the RIGHT instruction. Even though these are common instructions in many BF programs, it remains questionable if it is worth the effort to implement this for such relatively small gains with respect to the rise in complexity.

\paragraph{Designing a PCB} The system's instabilities would likely vanish if it was implemented on a PCB, due to very short connections to large voltage and ground planes and stable traces between IC's. If this direction is ever going to be pursued, most LED's would probably be removed to minimize the PCB's footprint. We would also have to consider how the program ROM can be inserted and removed easily; maybe even using ROM on an expansion card like the NES of the old days. For maximal modularity, the IO module could be implemented as an expansion card; different implementations (perhaps even using graphics or sound instead of ASCII-characters as its output-mode) could easily be swapped in and out.

\paragraph{Going Full 16-bit} In Section \ref{sec:implementation:ram} it was mentioned that the vast majority of memory-cells in the second SRAM-chip are left unused. Only the high byte of the IP values is stored in this chip when the IP is pushed to the stack on entering a loop, for a maximum of 256 bytes stored on a 512kb memory chip (effectively 64kb because of the 16-bit address bus); none of the other cells are ever used. Since the data bus is already 16-bits wide, it would have been fairly easy to make the D-register a 16-bit value as well. This would allow for BF programs that assume 16-bit data cells. Even though this was briefly considered in early stages of the project, we chose not to go through with it because a) it is not canonical BF and b) we did not want to make the system more complex than necessary at the time (we would effectively need a 16 input NOR-gate, requiring two more IC's on top of to the two additional register IC's). In hindsight, this would have been a nice (and pretty achievable) feature to have.

\paragraph{Using the '191} The 74LS191 seems like the perfect candidate to implement the counting registers. It simply has a U/D input to select the counting direction, a count-enable input (CTEN) and is connected directly to the clock. This is exactly how the register-modules behaved in early abstract designs of the system. The '191 was never used for the simple reason that we never knew about its existence and ordered the '193 instead; that was the first chip we encountered that could do the job. In hindsight - and purely by luck - the '193 was indeed the better choice because of its ability to (asynchronously) clear its values; the '191 has no clear input. This would have made it more difficult to implement clean reset functionality. Also, the number of control-lines to the modules would not have been different (U/D + CTEN instead of U + D), so the need for a register driver would still be there.

\paragraph{Decoupling Capacitors} When resorting to the internet (websites, forums, AI chatbots) to gather tips on stability, all of them mention the same potential solution: place decoupling capacitors (100~nF) as close as possible to the VCC and GND pins of every IC. Even though many of these have been placed around the board across the power rails, near the IC's, ideally they would have to be placed right across the IC's power pins (often located diagonally opposite one another). We never observed any improvements of placing such capacitors anywhere so - naively - we never sacrificed looks for potentially more stability (placing the caps across the IC's doesn't look very good in my opinion). If we were to start over again (and we won't), these capacitors would have to be integrated in the design, just to be sure.

\paragraph{Using AI} LLM's like ChatGPT have proven a valuable tool while designing and debugging the system. Let's be clear: no LLM's have been used to generate the text of this document or even write a single line of supporting code in the toolchain. It was however a valuable brainstorming partner when trying to find subtle logic bugs in both software and hardware. It almost never got it right completely on the first try, but it almost always inspired new avenues to explore. This more then often led to us identifying the problem eventually. Thinking out loud together with a partner will often lead to new insights and believe it or not, it is hard to find (human) sparring partners on a specialized project like this one.

\paragraph{IO Module: Cheating?} Should using an MCU in the implementation of the IO module be considered cheating? We set out to implement a BF computer without using any programmable chips, so clearly we broke our own rule, right? No. The entire BF core was implemented true to our mission goals: all BF commands are handled by TTL, RAM and ROM chips. The IO Module should be considered an abstract external device; its inner workings are irrelevant to the BF core logic in the same way that the BF language does not specify how user input is acquired or how data is displayed when issuing the \texttt{,} and \texttt{.} commands. Modern monitors and other peripherals often contain embedded driver chips that handle communication protocols or, in the case of monitors, display settings; this is no different.

\newpage
\mbox{}
\vfill
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{img/final_img}
\end{figure}


