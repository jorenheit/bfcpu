\section{Conclusion} \label{sec:conclusion}
\subsection{Retrospective}
The Synapse-191 project started as a fun challenge: could we build a full computer, from scratch, that speaks Brainf*ck as its native language? Not because it’s practical—because it’s interesting. Bit by bit, the design grew into a complete system: a microcoded CPU with a clean Harvard-like architecture, a two-phase clock, a working toolchain, and a surprisingly advanced I/O module. Somewhere along the way, the breadboards turned into a small city of logic chips, wires, and LEDs that somehow cooperate well enough to run real programs.

That’s not to say it’s perfect. In fact, it never has been fully stable. Especially the cheaper breadboards, some of which are still part of the system, proved to be have unreliable power rails. Bad connections to power or ground often lead to hard-to-debug problems. Still, the system works well enough to demonstrate every part of the design, and it’s a small miracle that it does so as reliably as it does.

If there’s ever a “next step,” it would be to take everything learned from this messy forest of jump wires and translate it onto a proper PCB. That would eliminate most of the grounding and signal integrity issues and turn this hand-built prototype into a stable, portable machine.

But even as it stands, the BFCPU has been a fantastic experiment—one that turned abstract ideas about microarchitecture, control logic, and timing into something you can literally touch. It’s a reminder that sometimes the best way to understand how computers work isn’t to simulate them, but to build one with your own hands—and then spend months trying to figure out why it occasionally forgets what “ground” means.

\subsection{Final Thoughts and Potential Improvements}
\paragraph{Virtual Registers} A big limitation of using the register driver as a centralized system to increment or decrement each register is the fact that only one register can be addressed per clock cycle. Having two addresses on the register driver still unconnected (addresses 110 and 111), their corresponding outputs could be connected to multiple registers that commonly need to increment together. For example, address 110 (bits RS2 and RS1) would then correspond to the virtual register D/IP. The corresponding U and D output signals would then be connected (through OR gates) to the counting inputs of both the D and IP register. Addressing this virtual register would then allow for incrementing or decrementing these registers simultaneously, which saves a clock cycle in the PLUS instruction. The MINUS instruction does not benifit from this trick, since we can't both decrement D and increment IP at the same time. The same could be done for DP and IP, saving a clock cycle in the RIGHT instruction. Even though these are common instructions in many BF programs, it remains questionable if it is worth the effort to implement this for such relatively small gains with respect to the rise in complexity.

\paragraph{Designing a PCB} The system's instabilities would likely vanish if it was implemented on a PCB, due to very short connections to large voltage and ground planes and stable traces between IC's. If this direction is ever going to be pursued, most LED's would probably be removed to minimize the PCB's footprint. We would also have to consider how the program ROM can be inserted and removed easily; maybe even using ROM on an expansion card like the NES of the old days. For maximal modularity, the IO module could be implemented as an expansion card; different implementations (perhaps even using graphics or sound instead of ASCII-characters as its output-mode) could easily be swapped in and out.

\paragraph{Going Full 16-bit} In Section \ref{sec:implementation:ram} it was mentioned that the vast majority of memory-cells in the second SRAM-chip are left unused. Only the high byte of the IP values is stored in this chip when the IP is pushed to the stack on entering a loop, for a maximum of 256 bytes stored on a 512kb memory chip (effectively 64kb because of the 16-bit address bus); none of the other cells are ever used. Since the data bus is already 16-bits wide, it would have been fairly easy to make the D-register a 16-bit value as well. This would allow for BF programs that assume 16-bit data cells. Even though this was briefly considered in early stages of the project, we chose not to go through with it because a) it is not canonical BF and b) we did not want to make the system more complex than necessary at the time (we would effectively need a 16 input NOR-gate, requiring two more IC's on top of to the two additional register IC's). In hindsight, this would have been a nice (and pretty achievable) feature to have.

\paragraph{Using the '191} The 74LS191 seems like the perfect candidate to implement the counting registers. It simply has a U/D input to select the counting direction, a count-enable input (CTEN) and is connected directly to the clock. This is exactly how the register-modules behaved in early abstract designs of the system. The '191 was never used for the simple reason that we never knew about its existence and ordered the '193 instead; that was the first chip we encountered that could do the job. In hindsight - and purely by luck - the '193 was indeed the better choice because of its ability to (asynchronously) clear its values; the '191 has no clear input. This would have made it more difficult to implement clean reset functionality. Also, the number of control-lines to the modules would not have been different (U/D + CTEN instead of U + D), so the need for a register driver would still be there.

\paragraph{Decoupling Capacitors} When resorting to the internet (websites, forums, AI chatbots) to gather tips on stability, all of them mention the same potential solution: place decoupling capacitors (100~nF) as close as possible to the VCC and GND pins of every IC. Even though many of these have been placed around the board across the power rails, near the IC's, ideally they would have to be placed right across the IC's power pins (often located diagonally opposite one another). We never observed any improvements of placing such capacitors anywhere so - naively - we never sacrificed looks for potentially more stability (placing the caps across the IC's doesn't look very good in my opinion). If we were to start over again (and we won't), these capacitors would have to be integrated in the design, just to be sure.

\paragraph{Using AI} LLM's like ChatGPT have proven a valuable tool while designing and debugging the system. Let's be clear: no LLM's have been used to generate the text of this document or even write a single line of supporting code in the toolchain. It was however a valuable brainstorming partner when trying to find subtle logic bugs in both software and hardware. It almost never got it right completely on the first try, but it almost always inspired new avenues to explore. This more then often led to us identifying the problem eventually. Thinking out loud together with a partner will often lead to new insights and believe it or not; it is hard to find (human) sparring partners on a specialized project like this one.

\paragraph{IO Module: Cheating?} Should using an MCU in the implementation of the IO module be considered cheating? We set out to implement a BF computer without using any programmable chips, so clearly we broke our own rule, right? No. The entire BF core was implemented true to our mission goals: all BF commands are handled by TTL, RAM and ROM chips. The IO Module should be considered an abstract external device; its inner workings are irrelevant to the BF core logic in the same way that the BF language does not specify how user input is aquired or how data is displayed when issuing the \texttt{,} and \texttt{.} commands. Modern monitors and other peripherals often contain embedded driver chips that handle communication protocols or, in the case of monitors, display settings; this is no different.

\newpage
\mbox{}
\vfill
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{img/final_img}
\end{figure}


