\section{Utilities} \label{sec:utilities}
While designing and implementing the computer, several supporting utilities were developed. The assembler (\texttt{bfasm}) is responsible for translating BF programs (text) into machine language (binary), the programmer and its software are used to write data to EEPROM chips and Mugen aids in having a more maintainable microcode definition. Each of these 3 utilities will be described in more detail below.

\subsection{Assembler: \texttt{bfasm}} \label{sec:utilities:bfasm}
Even though the computer is designed to run BF natively, we can't just burn any text-file containing BF commands onto the program-ROM and expect it to execute them. Instead, each of these commands has to be translated into its corresponding binary opcode. Table \ref{tab:opcodes} lists all the available commands and the values that map to these commands. As explained in Section \ref{sec:sequences}, there are a few non-BF that have been added.

\begin{table}[H]
  \centering
  \begin{tabular}{c|c}
    Command & Opcode \\ \hline
    \texttt{NOP} & 0x00 \\
    \texttt{+} & 0x01 \\
    \texttt{-} & 0x02 \\
    \texttt{<} & 0x03 \\
    \texttt{>} & 0x04 \\
    \texttt{,} & 0x05 \\
    \texttt{.} & 0x06 \\
    \texttt{\detokenize{[}} & 0x07 \\
    \texttt{\detokenize{]}} & 0x08 \\
    \texttt{?} & 0x09 \\
    \texttt{WAIT\_EXT} & 0x0c \\
    \texttt{INIT} & 0x0d \\
    \texttt{HOME} & 0x0e \\
    \texttt{HLT}  & 0x0f 
  \end{tabular}
  \caption{Opcode values for each of the available commands.}
  \label{tab:opcodes}
\end{table}

\texttt{bfasm} performs pretty much a one-to-one transformation of the BF commands in the provided textfile into these values. It will add some preample commands to initialize the system and puts a \texttt{HLT} instruction at the end of the program to stop the computer when the program has finished (Figure \ref{fig:assembleoutput}).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{img/assembleroutput}
  \caption{Result of assembling a plaintext BF-file.}
  \label{fig:assembleoutput}
\end{figure}


\subsection{Programmer: \texttt{bflash}} \label{sec:utilities:bflash}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{img/programmer}
  \caption{EEPROM chips were programmed using an Arduino Nano on a breadboard.}
  \label{fig:programmer}
\end{figure}

\subsubsection{Overview}
Given that there are four EEPROM chips embedded in the computer (one containing the program and three containing the microcode), we had to develop a toolkit for programming these. Specialized programmers can be pretty expensive and relatively hard to acquire, so an Arduino Nano was used to carry out that task. It waits for a serial connection and transfers incoming data byte per byte to the EEPROM chip. This serial connection is established by a Python script that accepts a binary blob and passes this on to the Arduino. The Python utility is called \texttt{bflash} (although it's not really BF-specific); its source and the Arduino sketch can be found at \url{https://github.com/jorenheit/bfcpu/tree/main/src/bflash}. A schematic for the programmer hardware (Figure \ref{fig:programmer}) is shown in Appendix \ref{sec:appendix:schematics}.

\subsubsection{Flashing the AT28C64B}
The AT28C64B 8x8K EEPROM chip is used for both microcode as program storage. A value can be written to a specific address by asserting  using the following sequence of inputs:
\begin{enumerate}
\item Assert the value and address onto the data and address lines of the EEPROM.
\item Set WE (Write Enable) low and OE (Output Enable) high. Both of these pins are active low, so this puts the chip in write-mode.
\item Hold CE (Chip Enable) low for at least 100ns; we chose 1$\mu$s because this is the smallest delay that can be performed using standard Arduino library functions.
\end{enumerate}

\subsubsection{Shift Register}
Because of the large number of connections to the EEPROM chip (13 address lines, 8 data lines and 3 control lines), two shift registers (74HC595) were used to buffer the address and WE/OE control lines.


\subsection{Microcode Compiler (Mugen)} \label{sec:utilities:mugen}
Initially, the binary images that were burnt onto the microcode EEPROM chips were generated using a simple Octave/Matlab script. This meant that both the microcode and the logic to generate the images had to be expressed in this language. While this certainly worked (albeit a bit slow), we felt the need to develop a more general approach to generating microcode images. To satisfy this need, Mugen was developed. It takes a file in which the microcode can be expressed intuitively and generates the binary images from it. The Mugen project can be found in \url{https://github.com/jorenheit/mugen}. Section \ref{sec:implementation:cu} shows the Mugen specification file for this project. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{img/mugen_logo}
\end{figure}

\subsection{Emulation Framework (Rinku)}
Before and during development of the physical system, a C++ framework was developed for emulating computational systems by defining modules and signals that connect them. The Synapse-191 has been emulated cycle-accurate using this framework, which could then be debugged interactively to identify issues with the logic of the real-life computer. Mugen was used to generate C++ source code containing the lookup tables that are normally flashed to the EEPROM chips, such that the same \texttt{.mu} files could be used to drive to real system as well as the emulated one. The Rinku project can be found on Github at \url{https://github.com/jorenheit/rinku/}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{img/rinku_logo}
\end{figure}
