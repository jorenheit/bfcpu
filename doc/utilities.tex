\section{Utilities} \label{sec:utilities}
While designing and implementing the computer, several supporting utilities were developed. The assembler (\texttt{bfasm}) is responsible for translating BF programs (text) into machine language (binary), the programmer and its software are used to write data to EEPROM chips and Mugen aids in having a more maintainable microcode definition. Each of these 3 utilities will be described in more detail below.

\subsection{Assembler: \texttt{bfasm}} \label{sec:utilities:bfasm}
Even though the computer is designed to run BF natively, we can't just burn any text-file containing BF commands onto the program-ROM and expect it to execute them. Instead, each of these commands has to be translated into its corresponding binary opcode. Table \ref{tab:opcodes} lists all the available commands and the values that map to these commands. As explained in Section \ref{sec:sequences}, there are a few non-BF that have been added.

\begin{table}[H]
  \centering
  \begin{tabular}{c|c}
    Command & Opcode \\ \hline
    \texttt{NOP} & 0x00 \\
    \texttt{+} & 0x01 \\
    \texttt{-} & 0x02 \\
    \texttt{<} & 0x03 \\
    \texttt{>} & 0x04 \\
    \texttt{,} & 0x05 \\
    \texttt{.} & 0x06 \\
    \texttt{\detokenize{[}} & 0x07 \\
    \texttt{\detokenize{]}} & 0x08 \\
    \texttt{?} & 0x09 \\
    \texttt{PROG\_START} & 0x0a \\
    \texttt{PROG\_END} & 0x0b \\
    \texttt{LOAD\_SLOT} & 0x0c \\
    \texttt{INIT} & 0x0d \\
    \texttt{INIT\_FINISH} & 0x0e \\
    \texttt{HALT}  & 0x0f 
  \end{tabular}
  \caption{Opcode values for each of the available commands.}
  \label{tab:opcodes}
\end{table}

\texttt{bfasm} performs pretty much a one-to-one transformation of the BF commands in the provided textfile into these values. It will add the preamble commands to initialize and bootload the system as was discussed in Section \ref{sec:sequences:binary} and shown in Figure \ref{fig:binary_format}).

\subsubsection{Features}
The \texttt{bfasm} utility provides the following features:
\paragraph{Zero Initialization} By default, only a single INIT instruction will be emitted in the preamble of the resulting binary file. This will initialize a single 256 byte block of RAM when the system boots. In practice this proved to be enough for most programs but if more is needed, \texttt{bfasm} has the option to emit an arbitrary amount of INIT instructions.
\paragraph{Print Filenames} Especially when multiple programs are written into a single binary, it can be helpful to see what program is running after loading a slot at runtime. The \texttt{-p} flag tells \texttt{bfasm} to generate BF code that prints the source filename before it actually runs. This code precedes the HALT instruction that is inserted right before the body of the program; the filename is displayed and the user can resume the clock knowing which program will run.
\paragraph{Interpret '!' as HALT} The BF commands do not include a command to stop the program. For debugging purposes, \texttt{bfasm} can interpret an exclamation mark in the BF source as a HALT instruction. This can be used to set breakpoints in the BF program.
\paragraph{Interpret '?' as RAND} The Random Brainf*ck Extension is supported by \texttt{bfasm}; when this option is enabled, each question mark in the BF source code will be assembled into a RAND instruction, which will place a random byte into the current cell (generated by the IO module).
\paragraph{Debug Mode} In debug-mode, each BF command is followed by a HALT instruction. This allows the user to step through the program on a command-level rather than on the cycle-level.
\paragraph{Echo} With the echo-mode enabled, each input-command will be followed by an output-command in order to see what's being typed on the keyboard (if the BF program does not already do this). This feature was deprecated when the IO-module itself started to provide this facility, but was left in \texttt{bfasm} anyway.
\paragraph{Bracket Matching} The assembler will not allow programs to contain unmatched brackets. This would for example mess up the logic for the bootloading opcodes and points to invalid BF programs in general. 

\vspace{1cm}
\begin{lstlisting}
Usage: ./bfasm [options] <file1, file2, ...>
Options:
-h, --help              Display this text.
-H, --halt-enable       Interpret '!' as HLT in the BF code
-r, --rand-enable       Interpret '?' as RAND in the BF code
-g, --debug             Place a breakpoint (!) after each instruction.
-e, --echo              Follow each input command (,) up by an output command (.) to echo keyboard input.
-d, --max-depth         Maximum nesting depth of []-pairs.
-z [N]                  Initialize N chunks of 256 bytes with zero's. Default: N = 1.
-u, --allow-unbalanced-loops
                        By default, the assembler will refuse to produce a program with unbalanced
                        loops ([ and ] do not match). Using this option will allow for this to occur.
-o [file, stdout]       Specify the output stream/file (default stdout).

Example: ./bfasm -o program.bin program.bf
\end{lstlisting}

\newpage
\subsection{Programmer: \texttt{bflash}} \label{sec:utilities:bflash}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{img/programmer}
  \caption{EEPROM chips were programmed using an Arduino Nano on a breadboard.}
  \label{fig:programmer}
\end{figure}

\subsubsection{Overview}
Given that there are four EEPROM chips embedded in the computer (one containing the program and three containing the microcode), we had to develop a toolkit for programming these. Specialized programmers can be pretty expensive and relatively hard to acquire, so an Arduino Nano was used to carry out that task. It waits for a serial connection and transfers incoming data byte per byte to the EEPROM chip. This serial connection is established by a Python script that accepts a binary blob and passes this on to the Arduino. The Python utility is called \texttt{bflash} (although it's not really BF-specific); its source and the Arduino sketch can be found at \url{https://github.com/jorenheit/bfcpu/tree/main/src/bflash}. A schematic for the programmer hardware (Figure \ref{fig:programmer}) is shown in Appendix \ref{sec:appendix:schematics}.

\subsubsection{Flashing the AT28C64B}
The AT28C64B 8x8K EEPROM chip is used for both microcode as program storage. A value can be written to a specific address by asserting  using the following sequence of inputs:
\begin{enumerate}
\item Assert the value and address onto the data and address lines of the EEPROM.
\item Set WE (Write Enable) low and OE (Output Enable) high. Both of these pins are active low, so this puts the chip in write-mode.
\item Hold CE (Chip Enable) low for at least 100ns; we chose 1$\mu$s because this is the smallest delay that can be performed using standard Arduino library functions.
\end{enumerate}

\subsubsection{Shift Register}
Because of the large number of connections to the EEPROM chip (13 address lines, 8 data lines and 3 control lines), two shift registers (74HC595) were used to buffer the address and WE/OE control lines.


\subsection{Microcode Compiler (Mugen)} \label{sec:utilities:mugen}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{img/mugen_logo}
\end{figure}

\subsubsection{Motivation}
Initially, the binary images that were burnt onto the microcode EEPROM chips were generated using a simple Octave/Matlab script. This meant that both the microcode and the logic to generate the images had to be expressed in this language. While this certainly worked (albeit a bit slow), we felt the need to develop a more general approach to generating microcode images. To satisfy this need, Mugen was developed. It takes a file in which the microcode can be expressed intuitively and generates the binary images from it. The Mugen project can be found in \url{https://github.com/jorenheit/mugen}. The listing in Appendix \ref{sec:appendix:mugen} shows the contents Mugen specification file for this project. 

\subsubsection{File Structure}
A Mugen file consists of four or five different sections in any order:
\begin{itemize}
\item \texttt{rom}: specifies the ROM configuration of the system;
\item \texttt{signals}: lists all the signals that make up the control word;
\item \texttt{opcodes}: lists all the opcodes of the CPU and assigns numerical values to them;
\item \texttt{address}: specifies how the microcode table address is formed from the opcode, cycle-count and flag-bits;
\item \texttt{microcode}: specifies the control-sequences for each of the opcodes;
\item \texttt{macros} (optional): lists common signal combinations that can be referred to by a single name in the microcode section (or within the macro section itself).
\end{itemize}

\newpage
\subsection{Emulation Framework (Rinku)}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{img/rinku_logo}
\end{figure}

Before and during development of the physical system, a C++ framework was developed for emulating computational systems by defining modules and signals that connect them. The Synapse-191 has been emulated cycle-accurate using this framework, which could then be debugged interactively to identify issues with the logic of the real-life computer. Mugen was used to generate C++ source code containing the lookup tables that are normally flashed to the EEPROM chips, such that the same \texttt{.mu} files could be used to drive to real system as well as the emulated one. The Rinku project can be found on Github at \url{https://github.com/jorenheit/rinku/}.

