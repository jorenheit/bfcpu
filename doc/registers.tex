\section{Registers} \label{sec:registers}
\subsection{Introduction}
This chapter will introduce the reader to an implementation of registers. As we had already pointed out, there are 7 registers in total; namely Data Pointer, Data, Stack, Loop Skip, Instruction, Instruction Pointer, and Flag register. Registers have built-in ability to increment and decrement the value stored in it, so that's why we used 74LS193 integrated chip. Here we have two possibilities: either we can have increment (UP) and decrement (DOWN) facility for every individual register, or we can have a common module with single UP-DOWN pair for every register. In this case, we also need some kind of select between registers. This is what Driver Module does for us. Before we delve into the Driver Module, register architecture will be explained.

\subsection{Register Architecture}
Registers are built using 74LS193 if they need both UP and DOWN functionality. In the case of only UP, as applies for Instruction Pointer, 74LS161 is used. For Flag register, which does not require UP and DOWN, simple 4-bit flip-flop can be used, 74LS****. Because 74LS193 and 74LS161 are 4-bit counters (they comprise the 4-bit register functionality as well), chaining is required to achieve 8-bit or 16-bit value. Referring to the 74LS193 datasheet \ref{74LS193}, we concluded that the chaining between 193-chips is done by connecting Carry-pin to Count-up-pin and Borrow-pin to Count-down-pin. Loading into the register is done by Load-pin, which is ACTIVE-LOW. Clearing is done by Clear-pin, which is ACTIVE-HIGH. Corresponding outputs and inputs of the stored value in a register are connected to other modules, as indicated by the computer architecture (\ref{fig:architecture}). Refer to *** for a more complete picture.

\subsection{Driver Module}
We create the Driver Module to get rid of excess number of UP-DOWN pairs for every single register. Regarding fig ***, we have eight inputs to the Driver Module and 2 * number of registers outputs. First two inputs are power (VCC) and ground (GND). Consider the datasheet for 74LS193 \ref{74LS193}, because the 74LS193 is incremented when DOWN is high and UP is clocked, and decremented when UP is high and DOWN is clocked, we need to specify the clock, mode (whether the register should be incremented or decremented when pulsed), and count enable (specify whether clock has an effect on incrementing/decrementing) inputs for the Driver Module. Furthermore, we have three more inputs, that specify what register is to be altered. The selecting is done by built-in-the-driver-module demultiplexer, that redirects pulses to the selected register's UP and DOWN pins. There are 7 registers in total, that can be decoded using 3 pins ($2^3 = 8 > 7$). Thus, we used 3-to-8 demultiplexer. For the complete picture, see fig. ***.

When designing the driver module, we encountered the problem associated with the 74LS193 integrated chip. Whenever UP and DOWN are low, clock pulsing will result into the altering of the register value based on the least significant bit stored. This means, that whenever count enable (CE) pin was LOW (so count is not available), there is still altering when clocking. The problem persisted not because of the circuit of the Driver Module, but because of the inner-circuit of 74LS193 integrated chip. The solution was quite straightforward: we need to avoid simultanious clocking with CE. We achieved this desired behavior by ANDing the clock with CE, and connect the output of AND to the CLK input of the Driver Module (see fig...)

\subsection{Additional Functionality of Registers}
... to be continued
 
